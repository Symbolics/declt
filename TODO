							     -*- outline -*-

* Copyright (C) 2010-2013, 2015-2017 Didier Verna

This file is part of Declt.

Copying and distribution of this file, with or without modification,
are permitted in any medium without royalty provided the copyright
notice and this notice are preserved.

** Packages and symbols
- See what to do about shadowings, imports etc.

** Docstrings
In theory, it is possible for a symbol/doc-type and a corresponding object to
have different docstrings attached (one would be manually overridden after the
original assignment). We could check that and advertise both.

** String downcasing
Abstract it so that we may provide an option for case behavior.

** Lisp objects formatting
There are many places where we'd prefer ~S (e.g. to preserve colons in front
of keywords), but that would break on unreadable objects. A solution would be
to "ignore-errors" on ~S, and fall back to ~A instead. Make this work along
with format-tables.

** Slots
Document not only direct slots, but also overloads (additional initargs etc).

** modify macros
Is there anything specific to do?

** Default values
Some standard values are not documented, e.g, standard method combination,
instance allocation, etc. We could provide a rendering option to make those
apparent.

** Backend
Clean up the code so that Texinfo becomes a backend with a clean
interface. This way, we could envision adding other backends.

There are several obstacles to this:
1. currently, the constructed node structure contains a mix of things to be
rendered (such as the nodes titles and sections) and this already rendered as
strings (definitions in :before-menu-contents). We would need to completely
separate the structure from its rendering so that the structure itself can be
passed along to various backends. That shouldn't be too hard tho. THe node
structure can be augmented by additional slots for, e.g., a list of
definitions to render.

2. Part of the cleanup would also be to decide on a good coding style for
fresh lines (FRESH-LINE, TERPRI, ~& and ~%).

3. Another problem that will happen is that the introduction and conclusion
material are currently allowed to contain Texinfo directives (contrary to all
other user-provided contents). This will be difficult to abstract if we
generalize the backend notion.

** Strings formatting
Provide markup support through backends (Cf. MarCL). We could already have at
least the current DWIM one, plus a raw/verbatim one.

** Pathnames
If the system definition pathname or definition sources contain funky stuff
like ./, ../ or even are symlinks, the cross-references will most probably
break. We need to work on canonical pathnames.

** Foreign definitions
Currently we grab symbols via systems -> files -> packages -> symbols.
This means that we may end up with definitions without a source file, because
it belongs to one of our package but, it was created outside. Those are not
considered foreign, but this is arguable.

In the same vein, definitions coming from one of our files but for a foreign
package (e.g. inisitalize-instance on one of our classes) should be considered
as belonging to us and we should document them. In that particular example,
this would require documenting a method as a toplevel definition.

If we go this route, we can already retrieve some of these definitions by
following links from previous definitions (e.g. class direct methods). But we
will certainly miss some (what about defvar foregin-package::variable ?).
There is a way to get everything, which is to DO-ALL-SYMBOLS. But this is
likely to degrade the performance by a noticeable amount, so I'm not ready to
do that just yet. Maybe this could be implemented as a user-level option.

[ Other definitions potentially concerned:
-  setf expanders for which the access-fn is foreign, but the
update-fn is ours. I currently don't know how to retrieve those. ]


** Call graphs
Cf.
sb-introspect:who-calls
sb-introspect:find-function-callees

** Source files
Currently, we can link to source files on the local machine, which is not
advisable for web installation of the reference manuals. However, if the
library provides a source control address, we could link to files in a public
repo !

** Profiling
It may be nice to do it at some point. For example, I wonder if the abundance
of STRING-CAPITALIZE on category names is costly, in which case we could
change the protocol to provide both versions as premade compile-time strings.

** Memory address problems
I have trouble with EQL specializers on things that are probably created
dynamically at load-time. This happens in mcclim and
com.clearly-useful.generic-collection-interface. There are references to
things like #<EQLSPECIALIZER ... {address}>, but later on (in method
definitions), the hexadecimal address seems to have changed. I don't know what
to do about this. In fact, I don't fully understand the problem.

** Duplicate anchor problems
There are still some of those, due to very similar objects, such as different
classes with identical names (e.g. gendl:remote-object). I'm not sure about
the purpose of those. I probably have to implement a simpler anchoring
mechanism, sacrificing readability of anchors (that was for Info) by using
an auto-incrementing counter of some sort. There will still be a problem left:
the documentation will have different items looking *very* similar.
